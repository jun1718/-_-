# 객체지향프로그래밍 목차
- 1)객체
- 2)객체지향 프로그래밍

# 1)객체
## 1-1)객체의 정의
- 객체란 실세계의 개체를 상태와 기능으로 추상화한것을 의미한다.
실세계의 것을 모방하긴 했지만 모방한것은 아이디에 불과하다.
필요한 기능들만 뽑아서 간추리는 거나 필요에 맞게 확장 또는 변형하는것, 그것이 추상화인데 이런 추상화를 통해서 실세계의 개체를 객체로 가져와서 
실제 기능을 간추린 미니 객체를 만들수도 혹은 완전히 다른 방식으로 기능하는 객체를 만들수도 있는 것이다.

# 2)객체지향 프로그래밍
## 2-1)객체지향 프로그래밍의 정의
- 쉽게말해서 위와같은 객체를 적용하여 프로그래밍하자는 것이다.<br>
근데 위의 한줄만 말하면 심심하니 부연설명을 해 보겠다.<br>
아래와 같은 이유로 좋은코드를 구현하기 용이한것이 객체를 사용하는것이며 그밖에도 객체를 사용했을때 아래와 같은 장점이 있음으로 앞으로 이러한 객체를 사용해서 객체중심으로 개발하자는 것이 객체지향 프로그래밍이다.
  - 좋은코드
    -  좋은코드란 가독성, 재사용성, 테스트 용이성을 만족하는 코드를 뜻한다.
       - 객체는 특정 **역할**을 인식하기 용이하기때문에 줄글로 나열되어있는 코드보다 해당 역할을 빠르게 파악할수 있어서 코드 파악에 용이하여 가독성에 좋다.
       - 객체는 특정한 **기능**을 항상 내포하기때문에 해당 기능이 필요할때마다 객체를 가져와서 사용할수 있기에 재사용성이 높다.
       - 객체는 조금더 의미있는 단위로 나누기때문에(cf: SRP_Single Responsbility Principle_단일책임원칙) 특정 역할을 명확하게 가지고 있고 해당 역할을 맡았을때 수행해야할 책임을 가진다. 이런 특성상 객체는 책임 단위별로 잘 분리되며 전체가 완성되지 않아도 **책임단위별**로 개발이 되기때문에 테스트를 하기에 용이하다.

## 2-2)객체지향 프로그래밍의 단점(*참고1)
- 초기 생산성이 떨어진다.
  - 코드를 잘 나누고 설계하는 것은 매우 어려운데 이때문에 코드를 작성하기도 전에 많은 시간을 할애해야한다.
    - 규모가 작은경우에는 객체지향프로그래밍 설계비용이 이익보다 높을수 있다. 
- 실행속도저하(가독성, 양날의 검)
    - 코드는 절차지향적으로 수억수만줄을 그대로 적으나 객체지향프로그래밍으로 수조만줄을 적으나 컴퓨터입장에서는 똑같이 이해하고 실행할수 있다.
    <br>하지만 객체지향프로그래밍이 훨씬 복잡한 구조로 되어있기에 컴퓨터가 이해하는 속도가 상대적으로 느리다.  
- 예측불허 상태로인한 버그발생
  - 객체는 상태가 존재하고 이 상태는 변수를 만들어 관리한다. 이때 상태가 의도한바와 달리 예상치 못한 값이 들어가서 애플리케이션 내부에서 버그를 발생시킬수 있는데 이것이 객체지향프로그래밍의 치명적인 단점이다. 
    - 이를 해결하기위해서 함수형 프로그래밍이 등장했다.   
- 오버헤드발생
  - 객체는 메세지를 통해 소통하는데 이는 메소드를 호출하는 것을 의미한다.
    <br>이렇게 객체들과 소통을 하기때문에 실행시스템에 많은 overhead가 발생한다.
    - 사실상 하드웨어의 발전으로 많이 보완되었음2

## 2-3)객체지향 설계원칙
- SRP(Single Responsibility Principle) : 단일 책임원칙
  - 객체는 하나의 책임에 의해서 기능이 고려되어야하며 객체를 변경한다면 그것은 단하나의 이유에 의해서 변경해야한다.
- OCP (Open-Closed Principle) : 개방-폐쇄 원칙
  - 객체는 변경에는 닫혀있어야하나 확장에는 열려있야한다.
- LSP (Liskov Subsititution Principle) : 리스코프 치환 원칙
  - 상위객체 타입을 사용하는 어플리케이션에서 하위객체타입으로 변경하여도 문제없이 실행되어야한다.
- ISP (Interface Segregation Principle) : 인터페이스 분리 원칙
  - 인터페이스는 사용자기준으로 분리되어야한다.
- DIP (Dependency Inversion Principle) : 의존성 역전 원칙
  - 고수준 모듈은 저수준 모듈의 구현에 의존해선 안된다.
  - 특정 객체에서 다른객체를 참조할경우 특정객체에서 변화가 일어날시 그여파가 다시 자기자신까지 변경시킬수 있는데 이를 순환의존이라하며 이러한 순환의존을
  <br>해결하기 위해서 DIP를 사용한다.
    - 의존성을 해결하기위해선 아래 캡슐화를 사용하면 좋다.
      - 캡슐화 방식 2가지
        - Tell, Don't Ask   
        - 데미테르 법칙



# 참고
1)https://velog.io/@han-byul-yang/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%A5%EB%8B%A8%EC%A0%90

